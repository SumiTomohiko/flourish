
import sdl
import sdl.image
# XXX: h2yog cannot output SDL_BlitSurface. Wait for fixing this bug.
sdl.SDL_BlitSurface = sdl.SDL_UpperBlit

class SdlError > Exception
  def init(msg)
    super("{0}: {1}".format(msg, sdl.SDL_GetError()))
  end
end

def determine_data_dir()
  data_dir = __FILE__.dirname / "data"
  landmark = data_dir / "mouse_area.png"
  try
    File.open(landmark) do
    end
  except SystemError
  else
    return data_dir
  end
  return __FILE__.dirname / ".." / "share" / "games" / "flourish"
end

DATA_DIR = determine_data_dir()

def init_img(&block)
  flags = sdl.image.IMG_INIT_PNG
  if sdl.image.IMG_Init(flags) != flags
    raise SdlError.new("IMG_Init failed")
  end
  try
    block()
  finally
    sdl.image.IMG_Quit()
  end
end

def init(width, height, bpp, caption, &block)
  sdl.SDL_Init(sdl.SDL_INIT_VIDEO)
  try
    init_img() do
      sdl.SDL_WM_SetCaption(caption, nil)
      flags = sdl.SDL_SWSURFACE | sdl.SDL_DOUBLEBUF | sdl.SDL_ANYFORMAT
      block(sdl.SDL_SetVideoMode(width, height, bpp, flags))
    end
  finally
    sdl.SDL_Quit()
  end
end

def run(controller, view)
  event = sdl.SDL_Event.new()
  loop() do
    sdl.SDL_PollEvent.while(1, event) do
      if controller.dispatch(event)
        return
      end
    end
    controller.animate()
    view.draw()
  end
end

BUTTON2NAME = {
  sdl.SDL_BUTTON_LEFT: "left", sdl.SDL_BUTTON_MIDDLE: "middle",
  sdl.SDL_BUTTON_RIGHT: "right", sdl.SDL_BUTTON_WHEELUP: "wheelup",
  sdl.SDL_BUTTON_WHEELDOWN: "wheeldown" }

class Controller
  def on_middle_button_released(x, y)
  end

  def on_wheelup_button_released(x, y)
  end

  def on_wheeldown_button_released(x, y)
  end

  def on_right_button_released(x, y)
  end

  def on_left_button_released(x, y)
  end

  def on_middle_button_pressed(x, y)
  end

  def on_wheelup_button_pressed(x, y)
  end

  def on_wheeldown_button_pressed(x, y)
  end

  def on_right_button_pressed(x, y)
  end

  def on_left_button_pressed(x, y)
  end

  def default_mousebutton_handler(button, x, y, suffix)
    name = "on_{0}_button_{1}".format(BUTTON2NAME[button], suffix)
    return self.get_attr(name)(x, y)
  end

  def on_mousebuttonup(button, x, y)
    return self.default_mousebutton_handler(button, x, y, "released")
  end

  def on_mousebuttondown(button, x, y)
    return self.default_mousebutton_handler(button, x, y, "pressed")
  end

  def fire_mousebutton_handler(event, f)
    mouse_button_event = event.button
    button = mouse_button_event.button
    x = mouse_button_event.x
    y = mouse_button_event.y
    return f(button, x, y)
  end

  def dispatch(event)
    if event.type == sdl.SDL_QUIT
      return true
    end
    if event.type == sdl.SDL_MOUSEBUTTONDOWN
      return self.fire_mousebutton_handler(event, self.on_mousebuttondown)
    end
    if event.type == sdl.SDL_MOUSEBUTTONUP
      return self.fire_mousebutton_handler(event, self.on_mousebuttonup)
    end
  end
end

class PlayerCharacter
  def init(x, y, direction)
    self.x = x
    self.y = y
    self.direction = direction # 'north, 'east, 'west or 'south
  end
end

CELL_SIZE = 80

# TODO: Rename this to index2pos
def pos2x(pos)
  return CELL_SIZE * pos + CELL_SIZE // 2
end

class Rect
  def init(x, y, width=CELL_SIZE, height=CELL_SIZE)
    self.x = x
    self.y = y
    self.width = width
    self.height = height
  end

  def include?(x, y)
    if (x < self.x) || (self.x + self.width < x)
      return false
    end
    if (y < self.y) || (self.y + self.height < y)
      return false
    end
    return true
  end
end

TURN_RIGHT_TABLE = {
  'north: 'east, 'east: 'south, 'south: 'west, 'west: 'north }
TURN_LEFT_TABLE = {
  'north: 'west, 'west: 'south, 'south: 'east, 'east: 'north }

class Rect2Act
  def init(rect, act)
    self.pred? = rect.include?
    self.act = act
  end
end

VELOCITY = 2
STEP_TO_MOVE = CELL_SIZE // VELOCITY

class StageController > Controller
  def init(map, pc)
    self.map = map
    self.pc = pc

    self.coroutine = nil

    x = MAIN_VIEW_X + MAIN_VIEW_PC_X
    y = MAIN_VIEW_Y + MAIN_VIEW_PC_Y
    pc_cell_left_x = x - CELL_SIZE // 2
    self.move_forward_area = Rect.new(
      pc_cell_left_x, y - CELL_SIZE - CELL_SIZE // 2)

    turn_area_y = y - CELL_SIZE
    pc_cell_right_x = x + CELL_SIZE // 2
    self.turn_left_area = Rect.new(pc_cell_left_x - CELL_SIZE, turn_area_y)
    self.turn_right_area = Rect.new(pc_cell_right_x, turn_area_y)

    backward_area_height = CELL_SIZE // 2
    self.move_backward_area = Rect.new(
      pc_cell_left_x, y + CELL_SIZE // 2,
      backward_area_height, backward_area_height)

    move_side_y = turn_area_y + CELL_SIZE
    self.move_left_area = Rect.new(pc_cell_left_x - CELL_SIZE, move_side_y)
    self.move_right_area = Rect.new(pc_cell_right_x, move_side_y)

    self.rect2act = [
      Rect2Act.new(self.move_forward_area, self.move_forward),
      Rect2Act.new(self.turn_left_area, self.turn_left),
      Rect2Act.new(self.turn_right_area, self.turn_right),
      Rect2Act.new(self.move_backward_area, self.move_backword),
      Rect2Act.new(self.move_left_area, self.move_left),
      Rect2Act.new(self.move_right_area, self.move_right)]
  end

  def animate()
    if self.coroutine == nil
      return
    end
    if self.coroutine.dead?
      self.coroutine = nil
      return
    end
    self.coroutine.resume()
  end

  def move_right()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x + CELL_SIZE
      y = pc.y
    elif direction == 'east
      x = pc.x
      y = pc.y + CELL_SIZE
    elif direction == 'west
      x = pc.x
      y = pc.y - CELL_SIZE
    else
      x = pc.x - CELL_SIZE
      y = pc.y
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do
        direction = pc.direction
        if direction == 'north
          pc.x += VELOCITY
        elif direction == 'east
          pc.y += VELOCITY
        elif direction == 'south
          pc.x -= VELOCITY
        else
          pc.y -= VELOCITY
        end
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def move_left()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x - CELL_SIZE
      y = pc.y
    elif direction == 'east
      x = pc.x
      y = pc.y - CELL_SIZE
    elif direction == 'west
      x = pc.x
      y = pc.y + CELL_SIZE
    else
      x = pc.x + CELL_SIZE
      y = pc.y
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do
        direction = pc.direction
        if direction == 'north
          pc.x -= VELOCITY
        elif direction == 'east
          pc.y -= VELOCITY
        elif direction == 'south
          pc.x += VELOCITY
        else
          pc.y += VELOCITY
        end
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def move_backword()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x
      y = pc.y + CELL_SIZE
    elif direction == 'east
      x = pc.x - CELL_SIZE
      y = pc.y
    elif direction == 'west
      x = pc.x + CELL_SIZE
      y = pc.y
    else
      x = pc.x
      y = pc.y - CELL_SIZE
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do
        direction = pc.direction
        if direction == 'north
          pc.y += VELOCITY
        elif direction == 'east
          pc.x -= VELOCITY
        elif direction == 'south
          pc.y -= VELOCITY
        else
          pc.x += VELOCITY
        end
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def geometry?(x, y, expected)
    return self.map[y // CELL_SIZE][x // CELL_SIZE] == expected
  end

  def wall?(x, y)
    return self.geometry?(x, y, 'wall)
  end

  def goal?()
    pc = self.pc
    return self.geometry?(pc.x, pc.y, 'goal)
  end

  def check_goal()
    if !self.goal?()
      return
    end
    puts("Conglaturation!")
  end

  def move_forward()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x
      y = pc.y - CELL_SIZE
    elif direction == 'east
      x = pc.x + CELL_SIZE
      y = pc.y
    elif direction == 'west
      x = pc.x - CELL_SIZE
      y = pc.y
    else
      x = pc.x
      y = pc.y + CELL_SIZE
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do
        direction = pc.direction
        if direction == 'north
          pc.y -= VELOCITY
        elif direction == 'east
          pc.x += VELOCITY
        elif direction == 'south
          pc.y += VELOCITY
        else
          pc.x -= VELOCITY
        end
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def turn_right()
    pc = self.pc
    pc.direction = TURN_RIGHT_TABLE[pc.direction]
  end

  def turn_left()
    pc = self.pc
    pc.direction = TURN_LEFT_TABLE[pc.direction]
  end

  def on_left_button_pressed(x, y)
    if self.coroutine != nil
      return
    end
    self.rect2act.each() do [obj]
      if obj.pred?(x, y)
        return obj.act()
      end
    end
  end
end

def load_image(name)
  path = DATA_DIR / name
  if (img = sdl.image.IMG_Load(path)) == nil
    raise SdlError.new("IMG_Load failed")
  end
  try
    optimized = sdl.SDL_DisplayFormatAlpha(img)
  finally
    sdl.SDL_FreeSurface(img)
  end
  if optimized == nil
    raise SdlError.new("SDL_DisplayFormatAlpha failed")
  end
  return optimized
end

MAIN_VIEW_X = 120
MAIN_VIEW_Y = 40
MAIN_VIEW_WIDTH = 400
MAIN_VIEW_HEIGHT = 400
MAIN_VIEW_PC_X = MAIN_VIEW_WIDTH // 2
MAIN_VIEW_PC_Y = MAIN_VIEW_HEIGHT - CELL_SIZE

class Point
  def init(x=nil, y=nil)
    self.x = x
    self.y = y
  end

  def +(point)
    return Point.new(self.x + point.x, self.y + point.y)
  end

  def *(n)
    return Point.new(n * self.x, n * self.y)
  end

  def to_s()
    return "<Point x={0}, y={1}>".format(self.x, self.y)
  end
end

Delta = Point

class DrawData
  def init(pc, pc2top_left, top_left2dst, pos2index_diff)
    main_view_top_left = self.compute_main_view_top_left(pc, pc2top_left)
    self.dst = self.compute_first_dst(main_view_top_left, top_left2dst)
    self.index = self.pos2index(main_view_top_left, pos2index_diff)
  end

  def floor(n)
    return n // CELL_SIZE * CELL_SIZE
  end

  def pos2index(p, diff)
    #return Point.new((p.x + diff.x) // CELL_SIZE, (p.y + diff.y) // CELL_SIZE)
    return Point.new(p.x // CELL_SIZE, p.y // CELL_SIZE)
  end

  def compute_diff(n, delta)
    return self.floor(n) + delta - n
  end

  def compute_first_dst(top_left, top_left2dst)
    x = self.compute_diff(top_left.x, top_left2dst.x)
    y = self.compute_diff(top_left.y, top_left2dst.y)
    return self.first_dst2point(x, y)
  end

  def compute_main_view_top_left(pc, pc2top_left)
    return Point.new(pc.x + pc2top_left.x, pc.y + pc2top_left.y)
  end

  def first_dst2point(x, y)
    raise NotImplementedError.new()
  end

  def init_horizontally(index)
    raise NotImplementedError.new()
  end

  def init_vertically(index)
    raise NotImplementedError.new()
  end

  def move_horizontally(index)
    raise NotImplementedError.new()
  end

  def move_vertically(index)
    raise NotImplementedError.new()
  end

  def get_index_of_neighbor(index)
    raise NotImplementedError.new()
  end

  def each_cells(&block)
    index = Point.new()
    dst = self.dst
    self.init_vertically(index)
    point = Point.new()
    dst.y.to(MAIN_VIEW_HEIGHT + 2 * CELL_SIZE, CELL_SIZE) do [y]
      bottom? = MAIN_VIEW_HEIGHT + CELL_SIZE < y
      self.init_horizontally(index)
      point.y = y
      dst.x.to(MAIN_VIEW_WIDTH, CELL_SIZE) do [x]
        point.x = x
        block(point, index, self.get_index_of_neighbor(index), bottom?)
        self.move_horizontally(index)
      end
      self.move_vertically(index)
    end
  end
end

class DrawDataNorth > DrawData
  def init(pc)
    pc2top_left = Delta.new(-MAIN_VIEW_PC_X, -MAIN_VIEW_PC_Y)
    top_left2dst = Delta.new(0, CELL_SIZE)
    super(pc, pc2top_left, top_left2dst, Delta.new(0, 0))
  end

  def first_dst2point(x, y)
    return Point.new(x, y)
  end

  def get_index_of_neighbor(index)
    return Point.new(index.x, index.y + 1)
  end

  def init_horizontally(index)
    index.x = self.index.x
  end

  def init_vertically(index)
    index.y = self.index.y
  end

  def move_horizontally(index)
    index.x += 1
  end

  def move_vertically(index)
    index.y += 1
  end
end

class DrawDataEast > DrawData
  def init(pc)
    pc2top_left = Delta.new(MAIN_VIEW_PC_Y - 1, -MAIN_VIEW_PC_X)
    top_left2dst = Delta.new(-1, 0)
    super(pc, pc2top_left, top_left2dst, Delta.new(0, 0))
  end

  def first_dst2point(x, y)
    return Point.new(y, -x)
  end

  def get_index_of_neighbor(index)
    return Point.new(index.x - 1, index.y)
  end

  def init_horizontally(index)
    index.y = self.index.y
  end

  def init_vertically(index)
    index.x = self.index.x
  end

  def move_horizontally(index)
    index.y += 1
  end

  def move_vertically(index)
    index.x -= 1
  end
end

class DrawDataWest > DrawData
  def init(pc)
    pc2top_left = Delta.new(-MAIN_VIEW_PC_Y, MAIN_VIEW_PC_X - 1)
    top_left2dst = Delta.new(CELL_SIZE, CELL_SIZE - 1)
    super(pc, pc2top_left, top_left2dst, Delta.new(0, -1))
  end

  def first_dst2point(x, y)
    return Point.new(-y, x)
  end

  def get_index_of_neighbor(index)
    return Point.new(index.x + 1, index.y)
  end

  def init_horizontally(index)
    index.y = self.index.y
  end

  def init_vertically(index)
    index.x = self.index.x
  end

  def move_horizontally(index)
    index.y -= 1
  end

  def move_vertically(index)
    index.x += 1
  end
end

class DrawDataSouth > DrawData
  def init(pc)
    pc2top_left = Delta.new(MAIN_VIEW_PC_X - 1, MAIN_VIEW_PC_Y - 1)
    top_left2dst = Delta.new(CELL_SIZE - 1, -1)
    super(pc, pc2top_left, top_left2dst, Delta.new(-1, 0))
  end

  def first_dst2point(x, y)
    return Point.new(-x, -y)
  end

  def get_index_of_neighbor(index)
    return Point.new(index.x, index.y - 1)
  end

  def init_horizontally(index)
    index.x = self.index.x
  end

  def init_vertically(index)
    index.y = self.index.y
  end

  def move_horizontally(index)
    index.x -= 1
  end

  def move_vertically(index)
    index.y -= 1
  end
end

def dump_point(filename, lineno, point)
  puts("{0}:{1} x={2}, y={3}".format(filename, lineno, point.x, point.y))
end

def dump_rect(filename, lineno, rect)
  fmt = "{0}:{1} x={2}, y={3}, w={4}, h={5}"
  puts(fmt.format(filename, lineno, rect.x, rect.y, rect.w, rect.h))
end

class View
  def cleanup_images()
    imgs = [
      self.mouse_area_img, self.pc_img, self.wall_img, self.ceil_img,
      self.floor_img]
    imgs.select() do [img]
      next img != nil
    end.each(&sdl.SDL_FreeSurface)
  end

  def init(map, pc, screen, &block)
    self.map = map
    self.pc = pc
    self.screen = screen

    self.pc_img = nil
    self.wall_img = nil
    self.ceil_img = nil
    self.floor_img = nil
    self.mouse_area_img = nil
    try
      self.pc_img = load_image("pc.png".to_path())
      self.wall_img = load_image("wall.png".to_path())
      self.ceil_img = load_image("ceil.png".to_path())
      self.floor_img = load_image("floor.png".to_path())
      self.mouse_area_img = load_image("mouse_area.png".to_path())

      self.draw_data = {
        'north: DrawDataNorth, 'east: DrawDataEast, 'west: DrawDataWest,
        'south: DrawDataSouth }
      self.geometry2img = { 'wall: self.wall_img }

      block(self)
    finally
      self.cleanup_images()
    end
  end

  def get_geometry(index)
    if (index.x < 0) || (index.y < 0)
      return nil
    end
    try
      return self.map[index.y][index.x]
    except IndexError
      return nil
    end
  end

  def get_surface(geometry)
    return self.geometry2img.get(geometry, self.floor_img)
  end

  def blit_surface(src, srcrect, dstrect)
    if sdl.SDL_BlitSurface(src, srcrect, self.screen, dstrect) != 0
      raise SdlError.new("SDL_BlitSurface failed")
    end
  end

  def cls()
    if sdl.SDL_FillRect(self.screen, nil, 0) != 0
      raise SdlError.new("SDL_FillRect failed")
    end
  end

  def shrink_floor(rect)
    max_height = 2 * CELL_SIZE - self.wall_img.h - self.ceil_img.h
    if max_height < rect.y
      rect.h = 0
      return
    end
    rect.h = max_height - rect.y
  end

  def cut_srcrect_y(srcrect, src, dst)
    if dst.y < 0
      srcrect.h = 0
      return
    end
    top = dst.y - src.h
    if MAIN_VIEW_HEIGHT <= top
      srcrect.h = 0
      return
    end
    if top < 0
      srcrect.y = -top
      srcrect.h = src.h - srcrect.y
      return
    end
    if MAIN_VIEW_HEIGHT <= dst.y
      srcrect.h = src.h - (dst.y - MAIN_VIEW_HEIGHT)
      return
    end
    srcrect.h = src.h
  end

  def cut_srcrect_x(srcrect, src, dst)
    if dst.x < 0
      srcrect.x = -dst.x
      srcrect.w = src.w - srcrect.x
      return
    end
    if MAIN_VIEW_WIDTH < dst.x + src.w
      srcrect.w = MAIN_VIEW_WIDTH - dst.x
      return
    end
    srcrect.w = src.w
  end

  def cut_surface(srcrect, src, dst)
    self.cut_srcrect_x(srcrect, src, dst)
    self.cut_srcrect_y(srcrect, src, dst)
  end

  def draw_floor(dst, neighbor)
    src = self.get_surface(nil)
    srcrect = sdl.SDL_Rect.new()
    self.cut_surface(srcrect, src, dst)
    if (neighbor == 'wall) && (dst.y < MAIN_VIEW_HEIGHT)
      self.shrink_floor(srcrect)
    end
    self.draw_surface(src, srcrect, dst)
  end

  def draw_surface(src, srcrect, dst)
    dstrect = sdl.SDL_Rect.new()
    dstrect.x = MAIN_VIEW_X + dst.x + srcrect.x
    dstrect.w = srcrect.w
    dstrect.y = MAIN_VIEW_Y + dst.y + srcrect.y - src.h
    dstrect.h = srcrect.h
    self.blit_surface(src, srcrect, dstrect)
  end

  def draw_wall(dst)
    src = self.get_surface('wall)
    srcrect = sdl.SDL_Rect.new()
    self.cut_surface(srcrect, src, dst)
    self.draw_surface(src, srcrect, dst)
  end

  def draw_ceil_on_wall(dst, diff)
    src = self.ceil_img
    srcrect = sdl.SDL_Rect.new()
    d = dst + Point.new(0, -self.wall_img.h - diff)
    self.cut_surface(srcrect, src, d)
    self.draw_surface(src, srcrect, d)
  end

  def get_upper_diff(direction)
    if direction == 'north
      return [0, -1]
    end
    if direction == 'east
      return [1, 0]
    end
    if direction == 'west
      return [-1, 0]
    end
    return [0, 1]
  end

  def get_upper_point(direction)
    return Point.new(*self.get_upper_diff(direction))
  end

  def get_upper_neighbor(index)
    return self.get_geometry(index + self.get_upper_point(self.pc.direction))
  end

  def find_wall_end(index, diff)
    if self.get_geometry(index) != 'wall
      return index
    end
    return self.find_wall_end(index + diff, diff)
  end

  def draw_ceil_overlapping_floor(dst, diff)
    src = self.ceil_img
    srcrect = sdl.SDL_Rect.new()
    (CELL_SIZE // self.ceil_img.h).times() do [n]
      y = dst.y - (CELL_SIZE * diff + n * src.h)
      if y < 0
        next
      end
      d = Point.new(dst.x, y)
      self.cut_surface(srcrect, src, d)
      self.draw_surface(src, srcrect, d)
    end
  end

  def draw_neighbor_ceils(dst, from_index, end_index)
    direction = self.pc.direction
    if direction == 'north
      return (end_index.y + 1).to(from_index.y + 1) do [n]
        self.draw_ceil_overlapping_floor(dst, from_index.y - n)
      end
    elif direction == 'east
      return from_index.x.to(end_index.x) do [n]
        self.draw_ceil_overlapping_floor(dst, n - from_index.x)
      end
    elif direction == 'west
      return (end_index.x + 1).to(from_index.x + 1) do [n]
        self.draw_ceil_overlapping_floor(dst, from_index.x - n)
      end
    end
    return from_index.y.to(end_index.y) do [n]
      self.draw_ceil_overlapping_floor(dst, n - from_index.y)
    end
  end

  def draw_end_ceil(dst, index)
    src = self.ceil_img
    height = self.wall_img.h + src.h - CELL_SIZE
    srcrect = sdl.SDL_Rect.new()
    (height // src.h).times() do [n]
      y = dst.y - n * src.h
      if y < 0
        next
      end
      d = Point.new(dst.x, y)
      self.cut_surface(srcrect, src, d)
      self.draw_surface(src, srcrect, d)
    end
  end

  def compute_ceils_size(from_index, end_index)
    direction = self.pc.direction
    if direction == 'north
      return from_index.y - end_index.y
    end
    if direction == 'east
      return end_index.x - from_index.x
    end
    if direction == 'west
      return from_index.x - end_index.x
    end
    return end_index.y - from_index.y
  end

  def draw_ceils(dst, index)
    self.draw_ceil_on_wall(dst, 0)
    if self.get_upper_neighbor(index) != 'wall
      return
    end
    self.draw_ceil_on_wall(dst, self.ceil_img.h)

    diff = self.get_upper_point(self.pc.direction)
    from_index = index + diff * 2
    end_index = self.find_wall_end(from_index, diff)
    d = Point.new(dst.x, dst.y - 2 * CELL_SIZE)
    self.draw_neighbor_ceils(d, from_index, end_index)

    size = self.compute_ceils_size(from_index, end_index)
    d = Point.new(dst.x, dst.y - CELL_SIZE * (2 + size))
    self.draw_end_ceil(d, end_index + diff)
  end

  def draw_main_view(data)
    data.each_cells() do [dst, index, neighbor, bottom?]
      geometry = self.get_geometry(neighbor)
      if self.get_geometry(index) == nil
        self.draw_floor(dst, geometry)
        next
      end
      if geometry == nil
        self.draw_wall(dst)
        self.draw_ceils(dst, index)
        next
      end
      if bottom?
        diff = self.get_upper_point(self.pc.direction)
        end_index = self.find_wall_end(index, diff)
        self.draw_neighbor_ceils(dst, index, end_index)

        size = self.compute_ceils_size(index, end_index)
        d = Point.new(dst.x, dst.y - CELL_SIZE * size)
        self.draw_end_ceil(d, end_index + diff)
      end
    end
  end

  def draw_mouse_area()
    MOUSE_AREA_WIDTH = 3 * CELL_SIZE
    MOUSE_AREA_HIGHT = 2 * CELL_SIZE + CELL_SIZE // 2

    srcrect = sdl.SDL_Rect.new()
    srcrect.x = 0
    srcrect.y = 0
    srcrect.w = MOUSE_AREA_WIDTH
    srcrect.h = MOUSE_AREA_HIGHT
    dstrect = sdl.SDL_Rect.new()
    dstrect.x = MAIN_VIEW_X + (MAIN_VIEW_WIDTH - MOUSE_AREA_WIDTH) // 2
    dstrect.y = MAIN_VIEW_Y + MAIN_VIEW_HEIGHT - MOUSE_AREA_HIGHT
    dstrect.w = srcrect.w
    dstrect.h = srcrect.h
    self.blit_surface(self.mouse_area_img, srcrect, dstrect)
  end

  def draw()
    self.cls()

    pc = self.pc
    self.draw_main_view(self.draw_data[pc.direction].new(pc))
    self.draw_mouse_area()

    if sdl.SDL_Flip(self.screen) != 0
      raise SdlError.new("SDL_Flip failed")
    end
  end
end

MAP_SIZE = 32

def generate_map(data)
  map_func = { "w": 'wall, "g": 'goal, " ":nil }.[]
  lines = data.rtrim().split("\n")
  if lines.size != MAP_SIZE
    raise SyntaxError.new("Invalid Map height: {0}".format(lines.size))
  end
  return lines.map() do [line]
    next (line + (MAP_SIZE - line.size) * " ").split("").map(&map_func)
  end
end

def get_config(type)
  if type == "simple"
    return <<EOF, Point.new(15, 26), 'south
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w                              w
w           www                w
w           www                w
w           www                w
w                              w
w                              w
w                              w
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
EOF
  end
  return <<EOF, Point.new(13, 28), 'north
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwgw
w    w w w w w w w w w w w w w w
wwww w                         w
w      w w w w w w w w w w w w w
w wwwwwwwwwwwwwwwwwwwwwwwwwwwwww
w       w   w   w              w
www www w w w w   w wwwwwwwwww w
w   ww  w   w wwwwwww          w
w w  w ww w w ww    w          w
w ww w w  w     w   w          w
w ww w   wwwwwwww   w wwwwwwwwww
wwww wwwww                     w
w         w wwwwwwwwwwwwwwwwwwww
w wwwwwww w  w w       ww      w
w     w ww w   w w       wwww ww
w wwwww     w  w w             w
w     w w  www   wwww wwwwwwww w
w www   ww   wwww        w     w
w   wwwww     w   wwwww  w wwwww
w       w    w  ww       w     w
wwwwww ww     w  wwwwwwwwwwwww w
w  www  ww  ww  wwww           w
w         w      w    www wwwwww
wwwwwwwww w   w   w  w     w   w
w       w     w    w w wwww  www
w    www    www   w w          w
www    w    w w      wwwwww  www
w      w          w w      w  ww
w   www w          w  www w w  w
w  ww   ww wwwwww w  w  w w  w w
w     w      ww     w         ww
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
EOF
end

def main(args)
  init(640, 480, 32, "Flourish") do [screen]
    txt, pos, direction = get_config(args.get(0))
    map = generate_map(txt)
    pc = PlayerCharacter.new(pos2x(pos.x), pos2x(pos.y), direction)
    View.new(map, pc, screen) do [view]
      run(StageController.new(map, pc), view)
    end
  end
end

if ARGV.get(0) == __FILE__
  main(ARGV.slice(1))
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
