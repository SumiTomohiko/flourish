
import sdl
import sdl.image
# XXX: h2yog cannot output SDL_BlitSurface. Wait for fixing this bug.
sdl.SDL_BlitSurface = sdl.SDL_UpperBlit

class SdlError > Exception
  def init(msg)
    super("{0}: {1}".format(msg, sdl.SDL_GetError()))
  end
end

def init_img(&block)
  flags = sdl.image.IMG_INIT_PNG
  if sdl.image.IMG_Init(flags) != flags
    raise SdlError.new("IMG_Init failed")
  end
  try
    block()
  finally
    sdl.image.IMG_Quit()
  end
end

def init(width, height, bpp, caption, &block)
  sdl.SDL_Init(sdl.SDL_INIT_VIDEO)
  try
    init_img() do
      sdl.SDL_WM_SetCaption(caption, nil)
      flags = sdl.SDL_SWSURFACE | sdl.SDL_DOUBLEBUF | sdl.SDL_ANYFORMAT
      block(sdl.SDL_SetVideoMode(width, height, bpp, flags))
    end
  finally
    sdl.SDL_Quit()
  end
end

def run(controller, view)
  event = sdl.SDL_Event.new()
  loop() do
    sdl.SDL_PollEvent.while(1, event) do
      if controller.dispatch(event)
        return
      end
    end
    controller.animate()
    view.draw()
  end
end

BUTTON2NAME = {
  sdl.SDL_BUTTON_LEFT: "left", sdl.SDL_BUTTON_MIDDLE: "middle",
  sdl.SDL_BUTTON_RIGHT: "right", sdl.SDL_BUTTON_WHEELUP: "wheelup",
  sdl.SDL_BUTTON_WHEELDOWN: "wheeldown" }

class Controller
  def on_middle_button_released(x, y)
  end

  def on_wheelup_button_released(x, y)
  end

  def on_wheeldown_button_released(x, y)
  end

  def on_right_button_released(x, y)
  end

  def on_left_button_released(x, y)
  end

  def on_middle_button_pressed(x, y)
  end

  def on_wheelup_button_pressed(x, y)
  end

  def on_wheeldown_button_pressed(x, y)
  end

  def on_right_button_pressed(x, y)
  end

  def on_left_button_pressed(x, y)
  end

  def default_mousebutton_handler(button, x, y, suffix)
    name = "on_{0}_button_{1}".format(BUTTON2NAME[button], suffix)
    return self.get_attr(name)(x, y)
  end

  def on_mousebuttonup(button, x, y)
    return self.default_mousebutton_handler(button, x, y, "released")
  end

  def on_mousebuttondown(button, x, y)
    return self.default_mousebutton_handler(button, x, y, "pressed")
  end

  def fire_mousebutton_handler(event, f)
    mouse_button_event = event.button
    button = mouse_button_event.button
    x = mouse_button_event.x
    y = mouse_button_event.y
    return f(button, x, y)
  end

  def dispatch(event)
    if event.type == sdl.SDL_QUIT
      return true
    end
    if event.type == sdl.SDL_MOUSEBUTTONDOWN
      return self.fire_mousebutton_handler(event, self.on_mousebuttondown)
    end
    if event.type == sdl.SDL_MOUSEBUTTONUP
      return self.fire_mousebutton_handler(event, self.on_mousebuttonup)
    end
  end
end

class PlayerCharacter
  def init(x, y, direction)
    self.x = x
    self.y = y
    self.direction = direction # 'north, 'east, 'west or 'south
  end
end

CELL_SIZE = 80

def pos2x(pos)
  return CELL_SIZE * pos + CELL_SIZE // 2
end

class Rect
  def init(x, y, width=CELL_SIZE, height=CELL_SIZE)
    self.x = x
    self.y = y
    self.width = width
    self.height = height
  end

  def include?(x, y)
    if (x < self.x) || (self.x + self.width < x)
      return false
    end
    if (y < self.y) || (self.y + self.height < y)
      return false
    end
    return true
  end
end

class StageController > Controller
  def init(map, pc)
    self.map = map
    self.pc = pc

    self.coroutine = nil

    pc_x = MAIN_VIEW_X + MAIN_VIEW_PC_X
    pc_y = MAIN_VIEW_Y + MAIN_VIEW_PC_Y
    self.forward_area = Rect.new(pc_x - CELL_SIZE // 2, pc_y - CELL_SIZE - CELL_SIZE // 2)
    self.left_turn_area = Rect.new(pc_x - CELL_SIZE - CELL_SIZE // 2, pc_y - CELL_SIZE)
    self.right_turn_area = Rect.new(pc_x + CELL_SIZE // 2, pc_y - CELL_SIZE)
  end

  def animate()
    if self.coroutine == nil
      return
    end
    if self.coroutine.dead?
      self.coroutine = nil
      return
    end
    self.coroutine.resume()
  end

  def move_forward()
    pc = self.pc
    if pc.y < CELL_SIZE
      return
    end
    self.coroutine = Coroutine.new() do
      CELL_SIZE.times() do
        direction = pc.direction
        if direction == 'north
          pc.y -= 1
        elif direction == 'east
          pc.x += 1
        elif direction == 'south
          pc.y += 1
        else
          pc.x -= 1
        end
        Coroutine.yield()
      end
    end
  end

  def turn_right()
    pc = self.pc
    tbl = { 'north: 'east, 'east: 'south, 'south: 'west, 'west: 'north }
    pc.direction = tbl[pc.direction]
  end

  def turn_left()
    pc = self.pc
    tbl = { 'north: 'west, 'west: 'south, 'south: 'east, 'east: 'north }
    pc.direction = tbl[pc.direction]
  end

  def on_left_button_pressed(x, y)
    if self.forward_area.include?(x, y)
      return self.move_forward()
    end
    if self.left_turn_area.include?(x, y)
      return self.turn_left()
    end
    if self.right_turn_area.include?(x, y)
      return self.turn_right()
    end
  end
end

def load_image2(name)
  path = __FILE__.dirname / name
  if (img = sdl.image.IMG_Load(path)) == nil
    raise SdlError.new("IMG_Load failed")
  end
  try
    optimized = sdl.SDL_DisplayFormatAlpha(img)
  finally
    sdl.SDL_FreeSurface(img)
  end
  if optimized == nil
    raise SdlError.new("SDL_DisplayFormatAlpha failed")
  end
  return optimized
end

def load_image(name)
  path = __FILE__.dirname / name
  if (img = sdl.SDL_LoadBMP(path)) == nil
    raise SdlError.new("SDL_LoadBMP failed")
  end
  return img
end

MAIN_VIEW_X = 120
MAIN_VIEW_Y = 40
MAIN_VIEW_WIDTH = 400
MAIN_VIEW_HEIGHT = 400
MAIN_VIEW_PC_X = MAIN_VIEW_WIDTH // 2
MAIN_VIEW_PC_Y = MAIN_VIEW_HEIGHT - CELL_SIZE

class View
  def cleanup_images()
    imgs = [self.mouse_area_img, self.pc_img, self.wall_img, self.ground_img]
    imgs.select() do [img]
      next img != nil
    end.each(&sdl.SDL_FreeSurface)
  end

  def init(map, pc, screen, &block)
    self.map = map
    self.pc = pc
    self.screen = screen

    self.pc_img = nil
    self.wall_img = nil
    self.ground_img = nil
    self.mouse_area_img = nil
    try
      self.pc_img = load_image("pc.bmp".to_path())
      self.wall_img = load_image("wall.bmp".to_path())
      self.ground_img = load_image("ground.bmp".to_path())
      self.mouse_area_img = load_image2("mouse_area.png".to_path())
      block(self)
    finally
      self.cleanup_images()
    end
  end

  def get_surface(x, y)
    if (x < 0) || (y < 0)
      return nil
    end
    try
      geometry = self.map[y][x]
    except IndexError
      return nil
    end
    return { 'wall: self.wall_img }.get(geometry, self.ground_img)
  end

  def blit_surface(src, srcrect, dstrect)
    if src == nil
      return
    end
    if sdl.SDL_BlitSurface(src, srcrect, self.screen, dstrect) != 0
      raise SdlError.new("SDL_BlitSurface failed")
    end
  end

  def cls()
    if sdl.SDL_FillRect(self.screen, nil, 0) != 0
      raise SdlError.new("SDL_FillRect failed")
    end
  end

  def draw_west()
    pc = self.pc
    top = pc.y - MAIN_VIEW_PC_X
    left = pc.x - MAIN_VIEW_PC_Y
    bottom = top + MAIN_VIEW_WIDTH
    right = left + MAIN_VIEW_HEIGHT

    srcrect = sdl.SDL_Rect.new()
    dstrect = sdl.SDL_Rect.new()

    x = left
    dstrect.y = MAIN_VIEW_Y
    while x < right
      if x + CELL_SIZE <= 0
        height = CELL_SIZE
        x += height
        dstrect.y += height
        next
      end

      i = x // CELL_SIZE
      srcrect.y = x - i * CELL_SIZE
      srcrect.h = min(CELL_SIZE - srcrect.y, right - x)

      height = srcrect.h
      dstrect.h = height

      y = bottom
      dstrect.x = MAIN_VIEW_X
      j = y // CELL_SIZE
      while top < y
        src = self.get_surface(i, j)
        srcrect.x = max(0, CELL_SIZE - (y - j * CELL_SIZE))
        width = CELL_SIZE - srcrect.x
        srcrect.w = width
        dstrect.w = width
        self.blit_surface(src, srcrect, dstrect)

        y -= width
        dstrect.x += width
        j -= 1
      end

      x += height
      dstrect.y += height
      i += 1
    end
  end

  def draw_east()
    pc = self.pc
    top = pc.y - MAIN_VIEW_PC_X
    right = pc.x + MAIN_VIEW_PC_Y
    bottom = top + MAIN_VIEW_WIDTH
    left = right - MAIN_VIEW_HEIGHT

    srcrect = sdl.SDL_Rect.new()
    dstrect = sdl.SDL_Rect.new()

    x = right
    dstrect.y = MAIN_VIEW_Y
    i = right // CELL_SIZE
    while left < x
      srcrect.y = CELL_SIZE - (x - i * CELL_SIZE)
      srcrect.h = min(CELL_SIZE - srcrect.y, x - left, CELL_SIZE)
      dstrect.h = srcrect.h

      y = top
      dstrect.x = MAIN_VIEW_X
      j = y // CELL_SIZE
      while y < bottom
        src = self.get_surface(i, j)
        srcrect.x = y - j * CELL_SIZE
        srcrect.w = min(bottom - y, CELL_SIZE)
        dstrect.w = srcrect.w
        self.blit_surface(src, srcrect, dstrect)

        y += dstrect.w
        dstrect.x += dstrect.w
        j += 1
      end

      x -= dstrect.h
      dstrect.y += dstrect.h
      i -= 1
    end
  end

  def draw_north()
    pc = self.pc
    left = pc.x - MAIN_VIEW_PC_X
    top = pc.y - MAIN_VIEW_PC_Y
    right = left + MAIN_VIEW_WIDTH
    bottom = top + MAIN_VIEW_HEIGHT

    srcrect = sdl.SDL_Rect.new()
    dstrect = sdl.SDL_Rect.new()

    y = top
    dstrect.y = MAIN_VIEW_Y
    j = pc.y // CELL_SIZE - MAIN_VIEW_PC_Y // CELL_SIZE
    while y < bottom
      srcrect.y = y - j * CELL_SIZE
      srcrect.h = min(CELL_SIZE - srcrect.y, bottom - y, CELL_SIZE)
      dstrect.h = srcrect.h

      x = left
      dstrect.x = MAIN_VIEW_X
      i = x // CELL_SIZE
      while x < right
        src = self.get_surface(i, j)
        srcrect.x = x - i * CELL_SIZE
        srcrect.w = min(right - x, CELL_SIZE)
        dstrect.w = srcrect.w
        self.blit_surface(src, srcrect, dstrect)

        x += dstrect.w
        dstrect.x += dstrect.w
        i += 1
      end

      y += dstrect.h
      dstrect.y += dstrect.h
      j += 1
    end
  end

  def draw_south()
    pc = self.pc
    bottom = pc.y + MAIN_VIEW_PC_Y
    left = pc.x - MAIN_VIEW_PC_X
    top = bottom - MAIN_VIEW_HEIGHT
    right = left + MAIN_VIEW_WIDTH

    srcrect = sdl.SDL_Rect.new()
    dstrect = sdl.SDL_Rect.new()

    y = bottom
    dstrect.y = MAIN_VIEW_Y
    while top < y
      if y + CELL_SIZE <= 0
        y -= CELL_SIZE
        dstrect.y += CELL_SIZE
        next
      end

      i = (y - 1) // CELL_SIZE
      srcrect.y = CELL_SIZE - (y - i * CELL_SIZE)
      srcrect.h = min(CELL_SIZE - srcrect.y, y - top)

      height = srcrect.h
      dstrect.h = height

      x = right
      dstrect.x = MAIN_VIEW_X
      j = x // CELL_SIZE
      while left < x
        src = self.get_surface(j, i)
        srcrect.x = max(0, CELL_SIZE - (x - j * CELL_SIZE))
        width = CELL_SIZE - srcrect.x
        srcrect.w = width
        dstrect.w = width
        self.blit_surface(src, srcrect, dstrect)

        x -= width
        dstrect.x += width
        j -= 1
      end

      y -= height
      dstrect.y += height
      i -= 1
    end
  end

  def draw_mouse_area()
    MOUSE_AREA_WIDTH = 3 * CELL_SIZE
    MOUSE_AREA_HIGHT = 2 * CELL_SIZE + CELL_SIZE // 2

    srcrect = sdl.SDL_Rect.new()
    srcrect.x = 0
    srcrect.y = 0
    srcrect.w = MOUSE_AREA_WIDTH
    srcrect.h = MOUSE_AREA_HIGHT
    dstrect = sdl.SDL_Rect.new()
    dstrect.x = MAIN_VIEW_X + (MAIN_VIEW_WIDTH - MOUSE_AREA_WIDTH) // 2
    dstrect.y = MAIN_VIEW_Y + MAIN_VIEW_HEIGHT - MOUSE_AREA_HIGHT
    dstrect.w = srcrect.w
    dstrect.h = srcrect.h
    self.blit_surface(self.mouse_area_img, srcrect, dstrect)
  end

  def draw()
    self.cls()

    {
      'north: self.draw_north, 'east: self.draw_east, 'west: self.draw_west,
      'south: self.draw_south }[self.pc.direction]()
    self.draw_mouse_area()

    if sdl.SDL_Flip(self.screen) != 0
      raise SdlError.new("SDL_Flip failed")
    end
  end
end

def main()
  init(640, 480, 32, "Flourish") do [screen]
    map = [
      ['wall, 'wall, 'wall, 'wall, 'wall, 'wall, 'wall, 'wall],
      ['wall, nil, nil, nil, nil, nil, nil, 'wall],
      ['wall, nil, nil, nil, nil, nil, nil, 'wall],
      ['wall, nil, nil, nil, nil, nil, nil, 'wall],
      ['wall, nil, nil, nil, nil, nil, nil, 'wall],
      ['wall, nil, nil, nil, nil, nil, nil, 'wall],
      ['wall, nil, nil, nil, nil, nil, nil, 'wall],
      ['wall, 'wall, 'wall, 'wall, 'wall, 'wall, 'wall, 'wall]]
    pc = PlayerCharacter.new(pos2x(1), pos2x(6), 'north)
    View.new(map, pc, screen) do [view]
      run(StageController.new(map, pc), view)
    end
  end
end

if ARGV.get(0) == __FILE__
  main()
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
