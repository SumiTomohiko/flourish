
import sdl
import sdl.image
# XXX: h2yog cannot output SDL_BlitSurface. Wait for fixing this bug.
sdl.SDL_BlitSurface = sdl.SDL_UpperBlit

class SdlError > Exception
  def init(msg)
    super("{0}: {1}".format(msg, sdl.SDL_GetError()))
  end
end

def init_img(&block)
  flags = sdl.image.IMG_INIT_PNG
  if sdl.image.IMG_Init(flags) != flags
    raise SdlError.new("IMG_Init failed")
  end
  try
    block()
  finally
    sdl.image.IMG_Quit()
  end
end

def init(width, height, bpp, caption, &block)
  sdl.SDL_Init(sdl.SDL_INIT_VIDEO)
  try
    init_img() do
      sdl.SDL_WM_SetCaption(caption, nil)
      flags = sdl.SDL_SWSURFACE | sdl.SDL_DOUBLEBUF | sdl.SDL_ANYFORMAT
      block(sdl.SDL_SetVideoMode(width, height, bpp, flags))
    end
  finally
    sdl.SDL_Quit()
  end
end

def run(controller, view)
  event = sdl.SDL_Event.new()
  loop() do
    sdl.SDL_PollEvent.while(1, event) do
      if controller.dispatch(event)
        return
      end
    end
    controller.animate()
    view.draw()
  end
end

BUTTON2NAME = {
  sdl.SDL_BUTTON_LEFT: "left", sdl.SDL_BUTTON_MIDDLE: "middle",
  sdl.SDL_BUTTON_RIGHT: "right", sdl.SDL_BUTTON_WHEELUP: "wheelup",
  sdl.SDL_BUTTON_WHEELDOWN: "wheeldown" }

class Controller
  def on_middle_button_released(x, y)
  end

  def on_wheelup_button_released(x, y)
  end

  def on_wheeldown_button_released(x, y)
  end

  def on_right_button_released(x, y)
  end

  def on_left_button_released(x, y)
  end

  def on_middle_button_pressed(x, y)
  end

  def on_wheelup_button_pressed(x, y)
  end

  def on_wheeldown_button_pressed(x, y)
  end

  def on_right_button_pressed(x, y)
  end

  def on_left_button_pressed(x, y)
  end

  def default_mousebutton_handler(button, x, y, suffix)
    name = "on_{0}_button_{1}".format(BUTTON2NAME[button], suffix)
    return self.get_attr(name)(x, y)
  end

  def on_mousebuttonup(button, x, y)
    return self.default_mousebutton_handler(button, x, y, "released")
  end

  def on_mousebuttondown(button, x, y)
    return self.default_mousebutton_handler(button, x, y, "pressed")
  end

  def fire_mousebutton_handler(event, f)
    mouse_button_event = event.button
    button = mouse_button_event.button
    x = mouse_button_event.x
    y = mouse_button_event.y
    return f(button, x, y)
  end

  def dispatch(event)
    if event.type == sdl.SDL_QUIT
      return true
    end
    if event.type == sdl.SDL_MOUSEBUTTONDOWN
      return self.fire_mousebutton_handler(event, self.on_mousebuttondown)
    end
    if event.type == sdl.SDL_MOUSEBUTTONUP
      return self.fire_mousebutton_handler(event, self.on_mousebuttonup)
    end
  end
end

class PlayerCharacter
  def init(x, y, direction)
    self.x = x
    self.y = y
    self.direction = direction # 'north, 'east, 'west or 'south
  end
end

CELL_SIZE = 80

def pos2x(pos)
  return CELL_SIZE * pos + CELL_SIZE // 2
end

class Rect
  def init(x, y, width=CELL_SIZE, height=CELL_SIZE)
    self.x = x
    self.y = y
    self.width = width
    self.height = height
  end

  def include?(x, y)
    if (x < self.x) || (self.x + self.width < x)
      return false
    end
    if (y < self.y) || (self.y + self.height < y)
      return false
    end
    return true
  end
end

TURN_RIGHT_TABLE = {
  'north: 'east, 'east: 'south, 'south: 'west, 'west: 'north }
TURN_LEFT_TABLE = {
  'north: 'west, 'west: 'south, 'south: 'east, 'east: 'north }

class Rect2Act
  def init(rect, act)
    self.pred? = rect.include?
    self.act = act
  end
end

VELOCITY = 2
STEP_TO_MOVE = CELL_SIZE // VELOCITY

class StageController > Controller
  def init(map, pc)
    self.map = map
    self.pc = pc

    self.coroutine = nil

    x = MAIN_VIEW_X + MAIN_VIEW_PC_X
    y = MAIN_VIEW_Y + MAIN_VIEW_PC_Y
    pc_cell_left_x = x - CELL_SIZE // 2
    self.move_forward_area = Rect.new(
      pc_cell_left_x, y - CELL_SIZE - CELL_SIZE // 2)

    turn_area_y = y - CELL_SIZE
    pc_cell_right_x = x + CELL_SIZE // 2
    self.turn_left_area = Rect.new(pc_cell_left_x - CELL_SIZE, turn_area_y)
    self.turn_right_area = Rect.new(pc_cell_right_x, turn_area_y)

    backward_area_height = CELL_SIZE // 2
    self.move_backward_area = Rect.new(
      pc_cell_left_x, y + CELL_SIZE // 2,
      backward_area_height, backward_area_height)

    move_side_y = turn_area_y + CELL_SIZE
    self.move_left_area = Rect.new(pc_cell_left_x - CELL_SIZE, move_side_y)
    self.move_right_area = Rect.new(pc_cell_right_x, move_side_y)

    self.rect2act = [
      Rect2Act.new(self.move_forward_area, self.move_forward),
      Rect2Act.new(self.turn_left_area, self.turn_left),
      Rect2Act.new(self.turn_right_area, self.turn_right),
      Rect2Act.new(self.move_backward_area, self.move_backword),
      Rect2Act.new(self.move_left_area, self.move_left),
      Rect2Act.new(self.move_right_area, self.move_right)]
  end

  def animate()
    if self.coroutine == nil
      return
    end
    if self.coroutine.dead?
      self.coroutine = nil
      return
    end
    self.coroutine.resume()
  end

  def move_right()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x + CELL_SIZE
      y = pc.y
    elif direction == 'east
      x = pc.x
      y = pc.y + CELL_SIZE
    elif direction == 'west
      x = pc.x
      y = pc.y - CELL_SIZE
    else
      x = pc.x - CELL_SIZE
      y = pc.y
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do
        direction = pc.direction
        if direction == 'north
          pc.x += VELOCITY
        elif direction == 'east
          pc.y += VELOCITY
        elif direction == 'south
          pc.x -= VELOCITY
        else
          pc.y -= VELOCITY
        end
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def move_left()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x - CELL_SIZE
      y = pc.y
    elif direction == 'east
      x = pc.x
      y = pc.y - CELL_SIZE
    elif direction == 'west
      x = pc.x
      y = pc.y + CELL_SIZE
    else
      x = pc.x + CELL_SIZE
      y = pc.y
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do
        direction = pc.direction
        if direction == 'north
          pc.x -= VELOCITY
        elif direction == 'east
          pc.y -= VELOCITY
        elif direction == 'south
          pc.x += VELOCITY
        else
          pc.y += VELOCITY
        end
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def move_backword()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x
      y = pc.y + CELL_SIZE
    elif direction == 'east
      x = pc.x - CELL_SIZE
      y = pc.y
    elif direction == 'west
      x = pc.x + CELL_SIZE
      y = pc.y
    else
      x = pc.x
      y = pc.y - CELL_SIZE
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do
        direction = pc.direction
        if direction == 'north
          pc.y += VELOCITY
        elif direction == 'east
          pc.x -= VELOCITY
        elif direction == 'south
          pc.y -= VELOCITY
        else
          pc.x += VELOCITY
        end
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def geometry?(x, y, expected)
    return self.map[y // CELL_SIZE][x // CELL_SIZE] == expected
  end

  def wall?(x, y)
    return self.geometry?(x, y, 'wall)
  end

  def goal?()
    pc = self.pc
    return self.geometry?(pc.x, pc.y, 'goal)
  end

  def check_goal()
    if !self.goal?()
      return
    end
    puts("Conglaturation!")
  end

  def move_forward()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x
      y = pc.y - CELL_SIZE
    elif direction == 'east
      x = pc.x + CELL_SIZE
      y = pc.y
    elif direction == 'west
      x = pc.x - CELL_SIZE
      y = pc.y
    else
      x = pc.x
      y = pc.y + CELL_SIZE
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do
        direction = pc.direction
        if direction == 'north
          pc.y -= VELOCITY
        elif direction == 'east
          pc.x += VELOCITY
        elif direction == 'south
          pc.y += VELOCITY
        else
          pc.x -= VELOCITY
        end
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def turn_right()
    pc = self.pc
    pc.direction = TURN_RIGHT_TABLE[pc.direction]
  end

  def turn_left()
    pc = self.pc
    pc.direction = TURN_LEFT_TABLE[pc.direction]
  end

  def on_left_button_pressed(x, y)
    if self.coroutine != nil
      return
    end
    self.rect2act.each() do [obj]
      if obj.pred?(x, y)
        return obj.act()
      end
    end
  end
end

def load_image2(name)
  path = __FILE__.dirname / name
  if (img = sdl.image.IMG_Load(path)) == nil
    raise SdlError.new("IMG_Load failed")
  end
  try
    optimized = sdl.SDL_DisplayFormatAlpha(img)
  finally
    sdl.SDL_FreeSurface(img)
  end
  if optimized == nil
    raise SdlError.new("SDL_DisplayFormatAlpha failed")
  end
  return optimized
end

def load_image(name)
  path = __FILE__.dirname / name
  if (img = sdl.SDL_LoadBMP(path)) == nil
    raise SdlError.new("SDL_LoadBMP failed")
  end
  return img
end

MAIN_VIEW_X = 120
MAIN_VIEW_Y = 40
MAIN_VIEW_WIDTH = 400
MAIN_VIEW_HEIGHT = 400
MAIN_VIEW_PC_X = MAIN_VIEW_WIDTH // 2
MAIN_VIEW_PC_Y = MAIN_VIEW_HEIGHT - CELL_SIZE

class View
  def cleanup_images()
    imgs = [self.mouse_area_img, self.pc_img, self.wall_img, self.ground_img]
    imgs.select() do [img]
      next img != nil
    end.each(&sdl.SDL_FreeSurface)
  end

  def init(map, pc, screen, &block)
    self.map = map
    self.pc = pc
    self.screen = screen

    self.pc_img = nil
    self.wall_img = nil
    self.ground_img = nil
    self.mouse_area_img = nil
    try
      self.pc_img = load_image("pc.bmp".to_path())
      self.wall_img = load_image("wall.bmp".to_path())
      self.ground_img = load_image("ground.bmp".to_path())
      self.mouse_area_img = load_image2("mouse_area.png".to_path())

      self.main_view_drawers = {
        'north: self.draw_north, 'east: self.draw_east, 'west: self.draw_west,
        'south: self.draw_south }

      block(self)
    finally
      self.cleanup_images()
    end
  end

  def get_surface(x, y)
    if (x < 0) || (y < 0)
      return nil
    end
    try
      geometry = self.map[y][x]
    except IndexError
      return nil
    end
    return { 'wall: self.wall_img }.get(geometry, self.ground_img)
  end

  def blit_surface(src, srcrect, dstrect)
    if src == nil
      return
    end
    if sdl.SDL_BlitSurface(src, srcrect, self.screen, dstrect) != 0
      raise SdlError.new("SDL_BlitSurface failed")
    end
  end

  def cls()
    if sdl.SDL_FillRect(self.screen, nil, 0) != 0
      raise SdlError.new("SDL_FillRect failed")
    end
  end

  def draw_west()
    pc = self.pc
    top = pc.y - MAIN_VIEW_PC_X
    left = pc.x - MAIN_VIEW_PC_Y
    bottom = top + MAIN_VIEW_WIDTH
    right = left + MAIN_VIEW_HEIGHT

    srcrect = sdl.SDL_Rect.new()
    dstrect = sdl.SDL_Rect.new()

    x = left
    dstrect.y = MAIN_VIEW_Y
    while x < right
      if x + CELL_SIZE <= 0
        height = CELL_SIZE
        x += height
        dstrect.y += height
        next
      end

      i = x // CELL_SIZE
      srcrect.y = x - i * CELL_SIZE
      srcrect.h = min(CELL_SIZE - srcrect.y, right - x)

      height = srcrect.h
      dstrect.h = height

      y = bottom
      dstrect.x = MAIN_VIEW_X
      j = y // CELL_SIZE
      while top < y
        src = self.get_surface(i, j)
        srcrect.x = max(0, CELL_SIZE - (y - j * CELL_SIZE))
        width = CELL_SIZE - srcrect.x
        srcrect.w = width
        dstrect.w = width
        self.blit_surface(src, srcrect, dstrect)

        y -= width
        dstrect.x += width
        j -= 1
      end

      x += height
      dstrect.y += height
      i += 1
    end
  end

  def draw_east()
    pc = self.pc
    top = pc.y - MAIN_VIEW_PC_X
    right = pc.x + MAIN_VIEW_PC_Y
    bottom = top + MAIN_VIEW_WIDTH
    left = right - MAIN_VIEW_HEIGHT

    srcrect = sdl.SDL_Rect.new()
    dstrect = sdl.SDL_Rect.new()

    x = right
    dstrect.y = MAIN_VIEW_Y
    i = right // CELL_SIZE
    while left < x
      srcrect.y = CELL_SIZE - (x - i * CELL_SIZE)
      srcrect.h = min(CELL_SIZE - srcrect.y, x - left, CELL_SIZE)
      dstrect.h = srcrect.h

      y = top
      dstrect.x = MAIN_VIEW_X
      j = y // CELL_SIZE
      while y < bottom
        src = self.get_surface(i, j)
        srcrect.x = y - j * CELL_SIZE
        srcrect.w = min(bottom - y, CELL_SIZE)
        dstrect.w = srcrect.w
        self.blit_surface(src, srcrect, dstrect)

        y += dstrect.w
        dstrect.x += dstrect.w
        j += 1
      end

      x -= dstrect.h
      dstrect.y += dstrect.h
      i -= 1
    end
  end

  def draw_north()
    pc = self.pc
    left = pc.x - MAIN_VIEW_PC_X
    top = pc.y - MAIN_VIEW_PC_Y
    right = left + MAIN_VIEW_WIDTH
    bottom = top + MAIN_VIEW_HEIGHT

    srcrect = sdl.SDL_Rect.new()
    dstrect = sdl.SDL_Rect.new()

    y = top
    dstrect.y = MAIN_VIEW_Y
    j = pc.y // CELL_SIZE - MAIN_VIEW_PC_Y // CELL_SIZE
    while y < bottom
      srcrect.y = y - j * CELL_SIZE
      srcrect.h = min(CELL_SIZE - srcrect.y, bottom - y, CELL_SIZE)
      dstrect.h = srcrect.h

      x = left
      dstrect.x = MAIN_VIEW_X
      i = x // CELL_SIZE
      while x < right
        src = self.get_surface(i, j)
        srcrect.x = x - i * CELL_SIZE
        srcrect.w = min(right - x, CELL_SIZE)
        dstrect.w = srcrect.w
        self.blit_surface(src, srcrect, dstrect)

        x += dstrect.w
        dstrect.x += dstrect.w
        i += 1
      end

      y += dstrect.h
      dstrect.y += dstrect.h
      j += 1
    end
  end

  def draw_south()
    pc = self.pc
    bottom = pc.y + MAIN_VIEW_PC_Y
    left = pc.x - MAIN_VIEW_PC_X
    top = bottom - MAIN_VIEW_HEIGHT
    right = left + MAIN_VIEW_WIDTH

    srcrect = sdl.SDL_Rect.new()
    dstrect = sdl.SDL_Rect.new()

    y = bottom
    dstrect.y = MAIN_VIEW_Y
    while top < y
      if y + CELL_SIZE <= 0
        y -= CELL_SIZE
        dstrect.y += CELL_SIZE
        next
      end

      i = (y - 1) // CELL_SIZE
      srcrect.y = CELL_SIZE - (y - i * CELL_SIZE)
      srcrect.h = min(CELL_SIZE - srcrect.y, y - top)

      height = srcrect.h
      dstrect.h = height

      x = right
      dstrect.x = MAIN_VIEW_X
      j = x // CELL_SIZE
      while left < x
        src = self.get_surface(j, i)
        srcrect.x = max(0, CELL_SIZE - (x - j * CELL_SIZE))
        width = CELL_SIZE - srcrect.x
        srcrect.w = width
        dstrect.w = width
        self.blit_surface(src, srcrect, dstrect)

        x -= width
        dstrect.x += width
        j -= 1
      end

      y -= height
      dstrect.y += height
      i -= 1
    end
  end

  def draw_mouse_area()
    MOUSE_AREA_WIDTH = 3 * CELL_SIZE
    MOUSE_AREA_HIGHT = 2 * CELL_SIZE + CELL_SIZE // 2

    srcrect = sdl.SDL_Rect.new()
    srcrect.x = 0
    srcrect.y = 0
    srcrect.w = MOUSE_AREA_WIDTH
    srcrect.h = MOUSE_AREA_HIGHT
    dstrect = sdl.SDL_Rect.new()
    dstrect.x = MAIN_VIEW_X + (MAIN_VIEW_WIDTH - MOUSE_AREA_WIDTH) // 2
    dstrect.y = MAIN_VIEW_Y + MAIN_VIEW_HEIGHT - MOUSE_AREA_HIGHT
    dstrect.w = srcrect.w
    dstrect.h = srcrect.h
    self.blit_surface(self.mouse_area_img, srcrect, dstrect)
  end

  def draw()
    self.cls()

    self.main_view_drawers[self.pc.direction]()
    self.draw_mouse_area()

    if sdl.SDL_Flip(self.screen) != 0
      raise SdlError.new("SDL_Flip failed")
    end
  end
end

MAP_SIZE = 32

def generate_map(data)
  map_func = { "w": 'wall, "g": 'goal, " ":nil }.[]
  lines = data.rtrim().split("\n")
  if lines.size != MAP_SIZE
    raise SyntaxError.new("Invalid Map height: {0}".format(lines.size))
  end
  return lines.map() do [line]
    next (line + (MAP_SIZE - line.size) * " ").split("").map(&map_func)
  end
end

def main()
  init(640, 480, 32, "Flourish") do [screen]
    map = generate_map(<<EOF)
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwgw
w    w w w w w w w w w w w w w w
wwww w                         w
w      w w w w w w w w w w w w w
w wwwwwwwwwwwwwwwwwwwwwwwwwwwwww
w       w   w   w              w
www www w w w w   w wwwwwwwwww w
w   ww  w   w wwwwwww          w
w w  w ww w w ww    w          w
w ww w w  w     w   w          w
w ww w   wwwwwwww   w wwwwwwwwww
wwww wwwww                     w
w         w wwwwwwwwwwwwwwwwwwww
w wwwwwww w  w w       ww      w
w     w ww w   w w       wwww ww
w wwwww     w  w w             w
w     w w  www   wwww wwwwwwww w
w www   ww   wwww        w     w
w   wwwww     w   wwwww  w wwwww
w       w    w  ww       w     w
wwwwww ww     w  wwwwwwwwwwwww w
w  www  ww  ww  wwww           w
w         w      w    www wwwwww
wwwwwwwww w   w   w  w     w   w
w       w     w    w w wwww  www
w    www    www   w w          w
www    w    w w      wwwwww  www
w      w          w w      w  ww
w   www w          w  www w w  w
w  ww   ww wwwwww w  w  w w  w w
w     w      ww     w         ww
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
EOF
    pc = PlayerCharacter.new(pos2x(13), pos2x(28), 'north)
    View.new(map, pc, screen) do [view]
      run(StageController.new(map, pc), view)
    end
  end
end

if ARGV.get(0) == __FILE__
  main()
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
