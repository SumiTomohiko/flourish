
import yogame
from flourish.core import CELL_SIZE, MAIN_VIEW_PC_X, MAIN_VIEW_PC_Y, MAIN_VIEW_X, MAIN_VIEW_Y, Point, Rect

VELOCITY = 2
STEP_TO_MOVE = CELL_SIZE // VELOCITY

class Rect2Act
  def init(rect, act)
    self.pred? = rect.include?
    self.act = act
  end
end

TURN_RIGHT_TABLE = {
  'north: 'east, 'east: 'south, 'south: 'west, 'west: 'north }
TURN_LEFT_TABLE = {
  'north: 'west, 'west: 'south, 'south: 'east, 'east: 'north }

class Controller > yogame.Controller
  def init(map, pc, npc)
    self.map = map
    self.pc = pc
    self.npc = npc
    self.npc.each(&self.place_npc)

    self.coroutine = nil
    self.coroutines = self.make_coroutines()

    x = MAIN_VIEW_X + MAIN_VIEW_PC_X
    y = MAIN_VIEW_Y + MAIN_VIEW_PC_Y
    pc_cell_left_x = x - CELL_SIZE // 2
    self.move_forward_area = Rect.new(
      pc_cell_left_x, y - CELL_SIZE - CELL_SIZE // 2)

    turn_area_y = y - CELL_SIZE
    pc_cell_right_x = x + CELL_SIZE // 2
    self.turn_left_area = Rect.new(pc_cell_left_x - CELL_SIZE, turn_area_y)
    self.turn_right_area = Rect.new(pc_cell_right_x, turn_area_y)

    backward_area_height = CELL_SIZE // 2
    self.move_backward_area = Rect.new(
      pc_cell_left_x, y + CELL_SIZE // 2,
      backward_area_height, backward_area_height)

    move_side_y = turn_area_y + CELL_SIZE
    self.move_left_area = Rect.new(pc_cell_left_x - CELL_SIZE, move_side_y)
    self.move_right_area = Rect.new(pc_cell_right_x, move_side_y)

    self.rect2act = [
      Rect2Act.new(self.move_forward_area, self.move_forward),
      Rect2Act.new(self.turn_left_area, self.turn_left),
      Rect2Act.new(self.turn_right_area, self.turn_right),
      Rect2Act.new(self.move_backward_area, self.move_backword),
      Rect2Act.new(self.move_left_area, self.move_left),
      Rect2Act.new(self.move_right_area, self.move_right)]
  end

  def move_char(char, direction, len)
    direction = char.direction
    if direction == 'north
      char.y -= len
    elif direction == 'east
      char.x += len
    elif direction == 'south
      char.y += len
    else
      char.x -= len
    end
  end

  def get_next_pos(x, y, direction)
    pos = Point.new(x, y)
    if direction == 'north
      pos.y -= CELL_SIZE
    elif direction == 'east
      pos.x += CELL_SIZE
    elif direction == 'west
      pos.x -= CELL_SIZE
    else
      pos.y += CELL_SIZE
    end
    return pos
  end

  def place_npc(obj)
    # FIXME: place NPC randomly
    obj.x = self.pc.x
    obj.y = self.pc.y
  end

  def attack_pc(strength)
    self.pc.life -= strength
  end

  def make_coroutines()
    return Array.new(self.npc.size) do [i]
      next Coroutine.new() do
        loop() do
          char = self.npc[i]
          if 0 < char.life
            char.act(self)
            next
          end
          Coroutine.yield()
        end
      end
    end
  end

  def animate()
    self.coroutines.each() do [coro]
      coro.resume()
    end
    if self.coroutine == nil
      return
    end
    if self.coroutine.dead?
      self.coroutine = nil
      return
    end
    self.coroutine.resume()
  end

  def move_right()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x + CELL_SIZE
      y = pc.y
    elif direction == 'east
      x = pc.x
      y = pc.y + CELL_SIZE
    elif direction == 'west
      x = pc.x
      y = pc.y - CELL_SIZE
    else
      x = pc.x - CELL_SIZE
      y = pc.y
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do [i]
        pc.move_right(VELOCITY)
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def move_left()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x - CELL_SIZE
      y = pc.y
    elif direction == 'east
      x = pc.x
      y = pc.y - CELL_SIZE
    elif direction == 'west
      x = pc.x
      y = pc.y + CELL_SIZE
    else
      x = pc.x + CELL_SIZE
      y = pc.y
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do [i]
        pc.move_left(VELOCITY)
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def move_backword()
    pc = self.pc
    direction = pc.direction
    if direction == 'north
      x = pc.x
      y = pc.y + CELL_SIZE
    elif direction == 'east
      x = pc.x - CELL_SIZE
      y = pc.y
    elif direction == 'west
      x = pc.x + CELL_SIZE
      y = pc.y
    else
      x = pc.x
      y = pc.y - CELL_SIZE
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do [i]
        pc.move_backword(VELOCITY)
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def geometry?(x, y, expected)
    return self.map[y // CELL_SIZE][x // CELL_SIZE] == expected
  end

  def wall?(x, y)
    return self.geometry?(x, y, 'wall)
  end

  def goal?()
    pc = self.pc
    return self.geometry?(pc.x, pc.y, 'goal)
  end

  def check_goal()
    if !self.goal?()
      return
    end
    puts("Conglaturation!")
  end

  def attack_npc(char)
    char.life -= self.pc.strength
    if char.life < 0
      puts("Slime died")
    end
  end

  def move_forward()
    pc = self.pc
    self.npc.each() do [char]
      if pc.attackable?(char) && (0 < char.life)
        self.attack_npc(char)
        return
      end
    end

    direction = pc.direction
    if direction == 'north
      x = pc.x
      y = pc.y - CELL_SIZE
    elif direction == 'east
      x = pc.x + CELL_SIZE
      y = pc.y
    elif direction == 'west
      x = pc.x - CELL_SIZE
      y = pc.y
    else
      x = pc.x
      y = pc.y + CELL_SIZE
    end
    if self.wall?(x, y)
      return
    end

    self.coroutine = Coroutine.new() do
      STEP_TO_MOVE.times() do [i]
        pc.move_forward(VELOCITY)
        Coroutine.yield()
      end
      self.check_goal()
    end
  end

  def turn_right()
    pc = self.pc
    pc.direction = TURN_RIGHT_TABLE[pc.direction]
  end

  def turn_left()
    pc = self.pc
    pc.direction = TURN_LEFT_TABLE[pc.direction]
  end

  def on_left_button_pressed(x, y)
    if self.coroutine != nil
      return
    end
    self.rect2act.each() do [obj]
      if obj.pred?(x, y)
        return obj.act()
      end
    end
  end
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
